worker_processes auto;
# error_log /usr/local/openresty/nginx/logs/error.log debug;
# error_log stderr debug;

events {
  worker_connections 1024;
}

http {
  # resolver 8.8.8.8 1.1.1.1 valid=30s; # Google + Cloudflare DNS
  resolver 223.5.5.5 114.114.114.114 valid=30s; # 国内

  upstream fastapi_backend {
    server fastapi:8000;
  }

  server {
    listen      80;
    server_name meme.us.kg;
    return      301 https://$host:8888$request_uri;
  }

  server {
    listen                    443 ssl;
    server_name               memeniu.xyz;
    ssl_certificate           /etc/letsencrypt/live/memeniu.xyz/memeniu.xyz_bundle.pem;
    ssl_certificate_key       /etc/letsencrypt/live/memeniu.xyz/memeniu.xyz.key;
    # 优化后的SSL配置
    ssl_protocols             TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers               ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305;
    ssl_session_cache         shared:SSL:10m;
    ssl_session_timeout       1d;
    ssl_stapling_verify       on;

    location = /echo {
      echo "memeniu.xyz config!";
      echo "Hello from nginx!";
      echo "host = $host";
      echo "request_uri = $request_uri";
      echo "http_user_agent = $http_user_agent";
      echo "http_accept = $http_accept";
    }
  }

  server {
    listen                    443 ssl;
    server_name               meme.us.kg;
    # 证书路径（符号链接需确保权限）
    ssl_certificate           /etc/letsencrypt/live/meme.us.kg/fullchain.pem;
    ssl_certificate_key       /etc/letsencrypt/live/meme.us.kg/privkey.pem;
    # 优化后的SSL配置
    ssl_protocols             TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers               ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305;
    ssl_session_cache         shared:SSL:10m;
    ssl_session_timeout       1d;
    ssl_stapling_verify       on;

    # 健康检查端点
    location = /nginx {
      content_by_lua_block {
          ngx.log(ngx.DEBUG, "Hello from Nginx! Host: ", ngx.var.host)
          ngx.say("Hello there! Your secure connection is up and running! Stay cozy ~ (HTTPS)\nFrom: ", ngx.var.host)
      }
    }

    location = /echo {
      echo "meme.us.kg config!";
      echo "Hello from nginx!";
      echo "host = $host";
      echo "request_uri = $request_uri";
      echo "http_user_agent = $http_user_agent";
      echo "http_accept = $http_accept";
    }

    location ~* ^/proxy/(?<target_host>[^/]+)(?<target_path>.*)$ {
      access_by_lua_block {
        -- 记录目标主机和路径（用于调试）
        ngx.log(ngx.DEBUG, "Proxying to host: ", ngx.var.target_host, ", path: ", ngx.var.target_path)

        -- 可加白名单检查（Lua 更灵活）
        local allowed_hosts = {
            ["finance.pae.baidu.com"] = true,
            ["gushitong.baidu.com"] = true,
        }
        if not allowed_hosts[ngx.var.target_host] then
            ngx.log(ngx.WARN, "Blocked proxy request to unauthorized host: ", ngx.var.target_host)
            ngx.exit(403)
        end
      }

      # if ($request_method = 'OPTIONS') {
      #   add_header 'Access-Control-Max-Age' 1728000;
      #   add_header 'Content-Type' 'text/plain; charset=utf-8';
      #   add_header 'Content-Length' 0;
      #   return     204;
      # }

      add_header            'Access-Control-Allow-Origin' '*' always;
      add_header            'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'
        always;
      add_header            'Access-Control-Allow-Headers'
        'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'
        always;
      # 构造完整的目标 URL
      set                   $target_url "https://$target_host$target_path";
      # 检查是否有查询参数，如果有则附加
      if ($is_args) {
        set $target_url "$target_url?$args";
      }

      header_filter_by_lua_block {
        ngx.log(ngx.DEBUG, "to URL: ", ngx.var.target_url)
      }
      
      # 代理到动态目标
      proxy_pass            $target_url;
      # 请求头
      proxy_set_header      Host $target_host;
      proxy_set_header      User-Agent $http_user_agent;
      proxy_set_header      Accept $http_accept;
      proxy_ssl_server_name on;
      # 超时设置(可选)
      proxy_connect_timeout 10s;
      proxy_send_timeout    30s;
      proxy_read_timeout    30s;
    }

    # 反向代理配置
    location / {
      proxy_pass            http://fastapi_backend;
      proxy_set_header      Host $host;
      proxy_set_header      X-Real-IP $remote_addr;
      proxy_set_header      X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header      X-Forwarded-Proto $scheme;
      proxy_connect_timeout 120s;
      proxy_send_timeout    120s;
      proxy_read_timeout    120s;
      client_max_body_size  10M; # 根据需求调整大小
    }
  }
}